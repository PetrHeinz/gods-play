<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tile Generation Prototype</title>
  <style>
    .tile, .link {
      box-sizing: border-box;
      position: absolute;
      border-radius: 100%;
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      font-size: 0.75em;
      width: 1.5em;
      height: 1.5em;
      text-align: center;
    }
    .tile {
      background: rgba(27, 126, 60, 0.3);
      border: 2px solid rgba(0, 0, 0, 0.1);
    }
    .link {
      color: rgba(27, 52, 126, 0.3);
    }
  </style>
</head>
<body>
<script>
  const MIN_X = 50
  const MAX_X = 600
  const MIN_Y = 50
  const MAX_Y = 300
  const TILES = 40
  const LINKS = 4
  const RETRIES = 10
  const REPELLING = 100
  const BASIC_PULLING = 1
  const LINKED_PULLING_FRACTION = 10

  function getTiles() {
    for (let i = 0; i <= RETRIES; i++) {
      try {
        let tiles = createTiles(TILES, LINKS)
        console.log(
          tiles.map(tile => ({name: tile.name, linked: tile.links.map(link => link.other(tile).name)}))
        )
        return tiles
      } catch (error) {
        console.log('error during creation: ' + error)
      }
    }
    throw 'unable to get tiles'
  }

  function createTiles(tileCount, linkCount) {
    const tiles = []
    for (let i = 0; i < tileCount; i++) {
      const tile = {
        name: i,
        element: document.createElement('div'),
        x: MIN_X + Math.random()*(MAX_X-MIN_X),
        y: MIN_Y + Math.random()*(MAX_Y-MIN_Y),
        links: []
      }
      tile.element.textContent = tile.name
      tile.element.className = 'tile'
      tile.element.style.left = tile.x+'px'
      tile.element.style.top = tile.y+'px'

      tiles.push(tile)
    }
    for (let i = 0; i < tileCount; i++) {
      let n = 0
      while(tiles[i].links.length < linkCount) {
        if (n++ > 100) throw "too many retries"
        const tileToLink = tiles[Math.floor(Math.random()*tileCount)]
        //const tileToLink = tiles[n]
        if (tileToLink.links.length < linkCount) {
          tryToLinkTiles(tiles[i], tileToLink)
        }
      }
    }
    for (let i = 0; i < tileCount; i++) {
      document.body.appendChild(tiles[i].element)
      for (let n = 0; n < tiles[i].links.length; n++) {
        document.body.appendChild(tiles[i].links[n].element)
      }
    }
    return tiles
  }
  function tryToLinkTiles(tileA, tileB) {
    if (tileA === tileB || tileA.links.map(link => link.other(tileA)).indexOf(tileB) !== -1) {
      return
    }
    const link = {
      tileA: tileA,
      tileB: tileB,
      other: (tile) => tile === tileA ? tileB : tileA,
      element: document.createElement('div')
    }
    tileA.links.push(link)
    tileB.links.push(link)

    link.element.textContent = 'ï¹¡'
    link.element.className = 'link'
    link.element.style.left = (tileA.x + tileB.x)/2+'px'
    link.element.style.top = (tileA.y + tileB.y)/2+'px'
  }

  function addVectors(vectorA, vectorB) {
    return {x: vectorA.x+vectorB.x, y: vectorA.y+vectorB.y}
  }
  function subtractVectors(vectorA, vectorB) {
    return {x: vectorA.x-vectorB.x, y: vectorA.y-vectorB.y}
  }
  function multiplyVector(vector, number) {
    return {x: vector.x*number, y: vector.y*number}
  }
  function getVectorLength(vector) {
    return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
  }

  function moveTiles(tiles) {
    const movements = []
    for (let i = 0; i < tiles.length; i++) {
      let movement = {x: 0, y: 0}
      const tile = tiles[i]
      for (let n = 0; n < tiles.length; n++) {
        const otherTile = tiles[n]
        if (tile === otherTile) {
          continue
        }
        const repellingVector = subtractVectors(tile, otherTile)
        const repellingForce = REPELLING / Math.pow(getVectorLength(repellingVector), 2)
        movement = addVectors(movement, multiplyVector(repellingVector, repellingForce))

        const pullingVector = subtractVectors(otherTile, tile)
        let pullingForce = BASIC_PULLING / getVectorLength(pullingVector)
        if (tile.links.map(link => link.other(tile)).indexOf(otherTile) !== -1) {
          pullingForce += 1 / LINKED_PULLING_FRACTION
        }
        movement = addVectors(movement, multiplyVector(pullingVector, pullingForce))
      }
      movements.push(movement)
    }
    for (let i = 0; i < tiles.length; i++) {
      tiles[i].x += movements[i].x
      tiles[i].y += movements[i].y
      tiles[i].element.style.left = tiles[i].x+'px'
      tiles[i].element.style.top = tiles[i].y+'px'
    }
    for (let i = 0; i < tiles.length; i++) {
      for (let n = 0; n < tiles[i].links.length; n++) {
        const link = tiles[i].links[n]
        link.element.style.left = (link.tileA.x + link.tileB.x)/2+'px'
        link.element.style.top = (link.tileA.y + link.tileB.y)/2+'px'
      }
    }
  }

  const tiles = getTiles()

  window.setInterval(() => moveTiles(tiles), 10)
</script>
</body>
</html>
