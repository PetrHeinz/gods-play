<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tile Generation Prototype</title>
  <style>
    .tile, .link {
      box-sizing: border-box;
      position: absolute;
      border-radius: 100%;
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      font-size: 0.75em;
      width: 1.5em;
      height: 1.5em;
      text-align: center;
    }

    .tile {
      background: rgba(27, 126, 60, 0.3);
      border: 2px solid rgba(0, 0, 0, 0.1);
    }

    .link {
      color: rgba(27, 52, 126, 0.3);
    }
  </style>
</head>
<body>
<script>
  const MIN_X = 50
  const MAX_X = 600
  const MIN_Y = 50
  const MAX_Y = 300
  const TILES = 40
  const LINKS = 4
  const MAX_LINK_LENGTH = 1.75
  const REPELLING = 100
  const BASIC_PULLING = 1
  const LINKED_PULLING = 1.5
  const TICK = 5
  const LINKING_AFTER = 60
  const LINKING_EVERY = 10

  class Vector {
    constructor(x, y) {
      if (typeof x !== 'number' || typeof y !== 'number') {
        throw new Error('Vector must be created from numbers')
      }
      if (!isFinite(x) || !isFinite(y)) {
        throw new Error('Vector must be created from finite numbers')
      }
      this.x = x
      this.y = y
    }

    add(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y)
    }

    subtract(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y)
    }

    scale(scale) {
      return new Vector(this.x * scale, this.y * scale)
    }

    get unit() {
      if (this.size === 0) {
        return new Vector(1, 0)
      }

      return this.scale(1 / this.size)
    }

    get size() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
    }
  }

  class Tile {
    constructor(name, position) {
      this.name = name
      this.position = position
      this.links = []
      this.element = document.createElement('div')
      this.element.className = 'tile'
      this.updateDOM()
    }

    link(tile) {
      if (this === tile || this.isLinkedTo(tile)) {
        return
      }
      const link = new Link(this, tile)
      this.links.push(link)
      tile.links.push(link)

      return link
    }

    get linkedTiles() {
      return this.links.map(link => link.other(this))
    }

    isLinkedTo(tile) {
      return this.linkedTiles.indexOf(tile) !== -1
    }

    getDistanceFrom(tile) {
      return tile.position.subtract(this.position).size
    }

    getDirectionTo(tile) {
      return tile.position.subtract(this.position).unit
    }

    move(vector) {
      this.position = this.position.add(vector)
      this.updateDOM()
    }

    appendDOM(element) {
      element.appendChild(this.element)
      this.links.forEach(link => link.appendDOM(element))
    }

    updateDOM() {
      this.element.textContent = this.name
      this.element.style.left = this.position.x + 'px'
      this.element.style.top = this.position.y + 'px'
      this.links.forEach(link => link.updateDOM())
    }
  }

  class Link {
    constructor(tileA, tileB) {
      this.tileA = tileA
      this.tileB = tileB
      this.element = document.createElement('div')
      this.element.textContent = 'ï¹¡'
      this.element.className = 'link'
      this.updateDOM()
    }

    other(tile) {
      return tile === this.tileA ? this.tileB : this.tileA
    }

    appendDOM(element) {
      element.appendChild(this.element)
    }

    updateDOM() {
      this.element.style.left = (this.tileA.position.x + this.tileB.position.x) / 2 + 'px'
      this.element.style.top = (this.tileA.position.y + this.tileB.position.y) / 2 + 'px'
    }
  }

  function createTiles() {
    return Array(TILES).fill(undefined).map((value, index) => {
      const position = new Vector(Math.random() * (MAX_X - MIN_X) + MIN_X, Math.random() * (MAX_Y - MIN_Y) + MIN_Y)
      const tile = new Tile(index, position)
      tile.appendDOM(document.body)

      return tile
    })
  }

  function moveTiles(tiles) {
    tiles.map(tile => {
      return tiles.filter(otherTile => tile !== otherTile)
      .map(otherTile => {
        const pullingForce = BASIC_PULLING + (tile.isLinkedTo(otherTile) ? LINKED_PULLING : 0)
        const repellingForce = REPELLING / tile.getDistanceFrom(otherTile)

        return tile.getDirectionTo(otherTile).scale(pullingForce - repellingForce)
      }).reduce((previousVector, currentVector) => previousVector.add(currentVector), new Vector(0, 0))
    }).forEach((movement, index) => tiles[index].move(movement))
  }

  function linkPairOfTiles(tiles) {
    const links = tiles.map(tile => tile.links)
    .reduce((previousLinks, currentLinks) => previousLinks.concat(currentLinks), [])
    .filter((link, index, allLinks) => allLinks.indexOf(link) === index)
    const averageLinkSize = links.map(link => link.tileA.getDistanceFrom(link.tileB))
    .reduce((previousSize, currentSize) => previousSize + currentSize, 0) / links.length

    const centerVector = tiles.map(tile => tile.position)
    .reduce((previousVector, currentVector) => previousVector.add(currentVector), new Vector(0, 0))
    .scale(1 / tiles.length)

    const eligibleTiles = tiles.filter(tile => tile.links.length < LINKS)
    .sort((tileA, tileB) => centerVector.subtract(tileA.position).size - centerVector.subtract(tileB.position).size)

    while (eligibleTiles.length > 2) {
      const tileToLink = eligibleTiles.shift()
      const eligibleTilesToLink = eligibleTiles.filter(tile => !tile.isLinkedTo(tileToLink))
      .filter(tile => isNaN(averageLinkSize) || tile.getDistanceFrom(tileToLink) <= averageLinkSize * MAX_LINK_LENGTH)
      .sort((tileA, tileB) => tileA.getDistanceFrom(tileToLink) - tileB.getDistanceFrom(tileToLink))

      if (eligibleTilesToLink.length > 0) {
        tileToLink.link(eligibleTilesToLink.shift())
        .appendDOM(document.body)

        return
      }
    }
  }

  const tiles = createTiles()
  window.setInterval(() => moveTiles(tiles), TICK)
  window.setTimeout(() => {
    window.setInterval(() => linkPairOfTiles(tiles), LINKING_EVERY * TICK)
  }, LINKING_AFTER * TICK)
</script>
</body>
</html>
