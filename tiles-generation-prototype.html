<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tile Generation Prototype</title>
  <style>
    body {
      min-height: 100vh;
      margin: 0;
      padding: 0;
    }

    .tile, .link {
      box-sizing: border-box;
      position: absolute;
      border-radius: 100%;
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      font-size: 0.75em;
      width: 1.5em;
      height: 1.5em;
      text-align: center;
    }

    .tile {
      background: rgba(27, 126, 60, 0.3);
      border: 2px solid rgba(0, 0, 0, 0.1);
    }

    .link {
      color: rgba(27, 52, 126, 0.3);
    }
  </style>
</head>
<body>
</body>
<script>
  const MIN_X = 50
  const MAX_X = 600
  const MIN_Y = 50
  const MAX_Y = 300
  const TILES = 40
  const LINKS = 4
  const MAX_LINK_LENGTH = 1.75
  const REPELLING = 100
  const BASIC_PULLING = 1
  const LINKED_PULLING = 1.5
  const TICK = 5
  const LINKING_AFTER = 60
  const LINKING_EVERY = 10

  class Vector {
    constructor(x, y) {
      if (typeof x !== 'number' || typeof y !== 'number') {
        throw new Error('Vectors must be created from numbers')
      }
      if (!isFinite(x) || !isFinite(y)) {
        throw new Error('Vectors must be created from finite numbers')
      }
      this.x = x
      this.y = y
    }

    add(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y)
    }

    subtract(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y)
    }

    scale(scale) {
      return new Vector(this.x * scale, this.y * scale)
    }

    get unit() {
      if (this.size === 0) {
        throw new Error('Vectors with zero size have no unit vector')
      }

      return this.scale(1 / this.size)
    }

    get size() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
    }
  }

  class Tile {
    constructor(name, position) {
      this.name = name
      this.position = position
      this.links = []
      this.element = document.createElement('div')
      this.element.className = 'tile'
      this.updateDOM()
    }

    link(tile) {
      if (this === tile || this.isLinkedTo(tile)) {
        throw new Error('Tiles can link only different tiles that are not linked already')
      }
      const link = new Link(this, tile)
      this.links.push(link)
      tile.links.push(link)

      return link
    }

    get linkedTiles() {
      return this.links.map(link => link.getOther(this))
    }

    isLinkedTo(tile) {
      return this.linkedTiles.indexOf(tile) !== -1
    }

    getDistanceFrom(tile) {
      return tile.position.subtract(this.position).size
    }

    getDirectionTo(tile) {
      return tile.position.subtract(this.position).unit
    }

    move(vector) {
      this.position = this.position.add(vector)
      this.updateDOM()
    }

    appendDOM(element) {
      element.appendChild(this.element)
      this.links.forEach(link => link.appendDOM(element))
    }

    updateDOM() {
      this.element.textContent = this.name
      this.element.style.left = this.position.x + 'px'
      this.element.style.top = this.position.y + 'px'
      this.links.forEach(link => link.updateDOM())
    }
  }

  class Link {
    constructor(tileA, tileB) {
      this.tileA = tileA
      this.tileB = tileB
      this.element = document.createElement('div')
      this.element.textContent = 'ï¹¡'
      this.element.className = 'link'
      this.updateDOM()
    }

    getOther(tile) {
      return tile === this.tileA ? this.tileB : this.tileA
    }

    appendDOM(element) {
      element.appendChild(this.element)
    }

    get distance() {
      return this.tileA.getDistanceFrom(this.tileB)
    }

    updateDOM() {
      this.element.style.left = (this.tileA.position.x + this.tileB.position.x) / 2 + 'px'
      this.element.style.top = (this.tileA.position.y + this.tileB.position.y) / 2 + 'px'
    }
  }

  class Board {
    constructor(tiles, element) {
      this.tiles = []
      this.element = element
      tiles.forEach(tile => this.addTile(tile))
    }

    get links() {
      return this.tiles.map(tile => tile.links)
      .reduce((previousLinks, currentLinks) => previousLinks.concat(currentLinks), [])
      .filter((link, index, allLinks) => allLinks.indexOf(link) === index)
    }

    get averageLinkDistance() {
      return this.links.map(link => link.distance)
      .reduce((previousDistance, currentDistance) => previousDistance + currentDistance, 0) / this.links.length
    }

    get centerVector() {
      return this.tiles.map(tile => tile.position)
      .reduce((previousVector, currentVector) => previousVector.add(currentVector), new Vector(0, 0))
      .scale(1 / this.tiles.length)
    }

    linkTiles(tileA, tileB) {
      const link = tileA.link(tileB)
      link.appendDOM(this.element)

      return link
    }

    addTile(tile) {
      this.tiles.push(tile)
      tile.appendDOM(this.element)
    }

    moveTiles() {
      this.tiles.forEach(tile => {
        const movement = this.tiles.filter(otherTile => tile !== otherTile)
        .map(otherTile => {
          const pullingForce = BASIC_PULLING + (tile.isLinkedTo(otherTile) ? LINKED_PULLING : 0)
          const repellingForce = REPELLING / tile.getDistanceFrom(otherTile)

          return tile.getDirectionTo(otherTile).scale(pullingForce - repellingForce)
        }).reduce((previousVector, currentVector) => previousVector.add(currentVector), new Vector(0, 0))

        tile.move(movement)
      })
    }
  }

  function createTiles() {
    return Array(TILES).fill(undefined).map((value, index) => {
      const position = new Vector(Math.random() * (MAX_X - MIN_X) + MIN_X, Math.random() * (MAX_Y - MIN_Y) + MIN_Y)

      return new Tile(index, position)
    })
  }

  function linkPairOfTiles(board) {
    const eligibleTiles = board.tiles.filter(tile => tile.links.length < LINKS)
    .sort((tileA, tileB) => board.centerVector.subtract(tileA.position).size - board.centerVector.subtract(tileB.position).size)

    while (eligibleTiles.length > 2) {
      const tileToLink = eligibleTiles.shift()
      const eligibleTilesToLink = eligibleTiles.filter(tile => !tile.isLinkedTo(tileToLink))
      .filter(tile => isNaN(board.averageLinkDistance) || tile.getDistanceFrom(tileToLink) <= board.averageLinkDistance * MAX_LINK_LENGTH)
      .sort((tileA, tileB) => tileA.getDistanceFrom(tileToLink) - tileB.getDistanceFrom(tileToLink))

      if (eligibleTilesToLink.length > 0) {
        return board.linkTiles(tileToLink, eligibleTilesToLink.shift())
      }
    }
  }

  const board = new Board(createTiles(), document.body)

  window.setInterval(() => board.moveTiles(), TICK)
  window.setTimeout(() => {
    window.setInterval(() => linkPairOfTiles(board), LINKING_EVERY * TICK)
  }, LINKING_AFTER * TICK)

  document.body.addEventListener('mousedown', (event) => board.addTile(new Tile('#', new Vector(event.x, event.y))))

</script>
</html>
