<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tile Generation Prototype</title>
  <style>
    .tile, .link {
      box-sizing: border-box;
      position: absolute;
      border-radius: 100%;
      color: white;
      font-family: sans-serif;
      font-weight: bold;
      font-size: 0.75em;
      width: 1.5em;
      height: 1.5em;
      text-align: center;
    }

    .tile {
      background: rgba(27, 126, 60, 0.3);
      border: 2px solid rgba(0, 0, 0, 0.1);
    }

    .link {
      color: rgba(27, 52, 126, 0.3);
    }
  </style>
</head>
<body>
<script>
  const MIN_X = 50
  const MAX_X = 600
  const MIN_Y = 50
  const MAX_Y = 300
  const TILES = 40
  const LINKS = 4
  const MAX_LINK_LENGTH = 1.75
  const REPELLING = 100
  const BASIC_PULLING = 1
  const LINKED_PULLING_FRACTION = 10

  class Vector {
    constructor(x, y) {
      if (typeof x !== 'number' || typeof y !== 'number') {
        throw new Error('Vector must be created from numbers')
      }
      if (!isFinite(x) || !isFinite(y)) {
        throw new Error('Vector must be created from finite numbers')
      }
      this.x = x
      this.y = y
    }

    add(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y)
    }

    subtract(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y)
    }

    scale(scale) {
      return new Vector(this.x * scale, this.y * scale)
    }

    get size() {
      return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
    }
  }

  class Tile {
    constructor(name, position) {
      this.name = name
      this.position = position
      this.links = []
      this.element = document.createElement('div')
      this.element.className = 'tile'
      this.updateDOM()
    }

    link(tile) {
      if (this === tile || this.isLinkedTo(tile)) {
        return
      }
      const link = new Link(this, tile)
      this.links.push(link)
      tile.links.push(link)

      return link
    }

    get linkedTiles() {
      return this.links.map(link => link.other(this))
    }

    isLinkedTo(tile) {
      return this.linkedTiles.indexOf(tile) !== -1
    }

    move(vector) {
      this.position = this.position.add(vector)
      this.updateDOM()
    }

    appendDOM(element) {
      element.appendChild(this.element)
      this.links.forEach(link => link.appendDOM(element))
    }

    updateDOM() {
      this.element.textContent = this.name
      this.element.style.left = this.position.x + 'px'
      this.element.style.top = this.position.y + 'px'
      this.links.forEach(link => link.updateDOM())
    }
  }

  class Link {
    constructor(tileA, tileB) {
      this.tileA = tileA
      this.tileB = tileB
      this.element = document.createElement('div')
      this.element.textContent = 'ï¹¡'
      this.element.className = 'link'
      this.element.style.left = (this.tileA.position.x + this.tileB.position.x) / 2 + 'px'
      this.element.style.top = (this.tileA.position.y + this.tileB.position.y) / 2 + 'px'
    }

    other(tile) {
      return tile === this.tileA ? this.tileB : this.tileA
    }

    appendDOM(element) {
      element.appendChild(this.element)
    }

    updateDOM() {
      this.element.style.left = (this.tileA.position.x + this.tileB.position.x) / 2 + 'px'
      this.element.style.top = (this.tileA.position.y + this.tileB.position.y) / 2 + 'px'
    }
  }

  function createTiles() {
    const tiles = []
    for (let i = 0; i < TILES; i++) {
      const position = new Vector(Math.random() * (MAX_X - MIN_X) + MIN_X, Math.random() * (MAX_Y - MIN_Y) + MIN_Y)
      const tile = new Tile(i, position)
      tiles.push(tile)
      tile.appendDOM(document.body)
    }

    return tiles
  }

  function moveTiles(tiles) {
    const movements = []
    for (let i = 0; i < tiles.length; i++) {
      let movement = new Vector(0, 0)
      const tile = tiles[i]
      for (let n = 0; n < tiles.length; n++) {
        const otherTile = tiles[n]
        if (tile === otherTile) {
          continue
        }
        const repellingVector = tile.position.subtract(otherTile.position)
        const repellingForce = REPELLING / Math.pow(repellingVector.size, 2)
        movement = movement.add(repellingVector.scale(repellingForce))

        const pullingVector = otherTile.position.subtract(tile.position)
        let pullingForce = BASIC_PULLING / pullingVector.size
        if (tile.isLinkedTo(otherTile)) {
          pullingForce += 1 / LINKED_PULLING_FRACTION
        }
        movement = movement.add(pullingVector.scale(pullingForce))
      }
      movements.push(movement)
    }

    tiles.forEach((tile, i) => tile.move(movements[i]))
  }

  function linkPairOfTiles(tiles) {
    const links = tiles.map(tile => tile.links)
    .reduce((previousLinks, currentLinks) => previousLinks.concat(currentLinks), [])
    .filter((link, index, allLinks) => allLinks.indexOf(link) === index)
    const averageLinkSize = links.map(link => link.tileA.position.subtract(link.tileB.position).size)
    .reduce((previousSize, currentSize) => previousSize + currentSize, 0) / links.length

    const centerVector = tiles.map(tile => tile.position)
    .reduce((previousVector, currentVector) => previousVector.add(currentVector), new Vector(0, 0))
    .scale(1 / tiles.length)

    const eligibleTiles = tiles.filter(tile => tile.links.length < LINKS)
    .sort((tileA, tileB) => tileA.position.subtract(centerVector).size - tileB.position.subtract(centerVector).size)

    while (eligibleTiles.length > 2) {
      const tileToLink = eligibleTiles.shift()
      const eligibleTilesToLink = eligibleTiles.filter(tile => !tile.isLinkedTo(tileToLink))
      .filter(tile => isNaN(averageLinkSize) || tile.position.subtract(tileToLink.position).size <= averageLinkSize * MAX_LINK_LENGTH)
      .sort((tileA, tileB) => tileA.position.subtract(tileToLink.position).size - tileB.position.subtract(tileToLink.position).size)

      if (eligibleTilesToLink.length > 0) {
        tileToLink.link(eligibleTilesToLink.shift())
        .appendDOM(document.body)

        return
      }
    }
  }

  const tiles = createTiles()
  window.setInterval(() => moveTiles(tiles), 5)
  window.setTimeout(() => {
    window.setInterval(() => linkPairOfTiles(tiles), 50)
  }, 300)
</script>
</body>
</html>
